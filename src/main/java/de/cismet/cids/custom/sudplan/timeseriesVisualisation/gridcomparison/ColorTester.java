/***************************************************
*
* cismet GmbH, Saarbruecken, Germany
*
*              ... and it just works.
*
****************************************************/
package de.cismet.cids.custom.sudplan.timeseriesVisualisation.gridcomparison;

import com.sun.media.jai.codec.BMPEncodeParam;

import org.openide.util.Exceptions;

import java.awt.Color;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.awt.image.SampleModel;
import java.awt.image.renderable.ParameterBlock;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import javax.imageio.ImageIO;

import javax.media.jai.JAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.RasterFactory;

import javax.swing.ImageIcon;

/**
 * DOCUMENT ME!
 *
 * @author   jweintraut
 * @version  $Revision$, $Date$
 */
public class ColorTester extends javax.swing.JFrame {

    //~ Static fields/initializers ---------------------------------------------

    private static final int ADD = 0;
    private static final int SUB = 1;
    private static final int MUL = 2;
    private static final int DIV = 3;

    //~ Instance fields --------------------------------------------------------

    private BufferedImage firstOperandRGB;
    private BufferedImage secondOperandRGB;
    private BufferedImage firstOperandHSV;
    private BufferedImage secondOperandHSV;
    private PlanarImage firstOperandRGBJAI;
    private PlanarImage secondOperandRGBJAI;
    private PlanarImage firstOperandHSVJAI;
    private PlanarImage secondOperandHSVJAI;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox cmdOperation;
    private javax.swing.JLabel lblFirstOperand;
    private javax.swing.JLabel lblFirstOperandHSV;
    private javax.swing.JLabel lblFirstOperandRGB;
    private javax.swing.JLabel lblHSV;
    private javax.swing.JLabel lblRGB;
    private javax.swing.JLabel lblResultHSV;
    private javax.swing.JLabel lblResultHSVHSV;
    private javax.swing.JLabel lblResultHSVRGB;
    private javax.swing.JLabel lblResultRGB;
    private javax.swing.JLabel lblResultRGBHSV;
    private javax.swing.JLabel lblResultRGBRGB;
    private javax.swing.JLabel lblSecondOperand;
    private javax.swing.JLabel lblSecondOperandHSV;
    private javax.swing.JLabel lblSecondOperandRGB;
    private javax.swing.JPanel pnlResultHSVJAI;
    private javax.swing.JPanel pnlResultRGBJAI;
    // End of variables declaration//GEN-END:variables

    //~ Constructors -----------------------------------------------------------

    /**
     * Creates new form ColorTester.
     */
    public ColorTester() {
        initComponents();

        try {
            firstOperandRGB = ImageIO.read(ColorTester.class.getResource("05.png"));
            secondOperandRGB = ImageIO.read(ColorTester.class.getResource("06.png"));
            firstOperandHSV = ImageIO.read(ColorTester.class.getResource("05hsv.png"));
            secondOperandHSV = ImageIO.read(ColorTester.class.getResource("06hsv.png"));
            firstOperandRGBJAI = JAI.create("url", ColorTester.class.getResource("05.png"));
            secondOperandRGBJAI = JAI.create("url", ColorTester.class.getResource("06.png"));
            firstOperandHSVJAI = JAI.create("url", ColorTester.class.getResource("05hsv.png"));
            secondOperandHSVJAI = JAI.create("url", ColorTester.class.getResource("06hsv.png"));
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }

        if ((firstOperandRGB != null) && (secondOperandRGB != null)) {
            lblFirstOperandRGB.setIcon(new ImageIcon(firstOperandRGB));
            lblSecondOperandRGB.setIcon(new ImageIcon(secondOperandRGB));
        }
        if ((firstOperandHSV != null) && (secondOperandHSV != null)) {
            lblFirstOperandHSV.setIcon(new ImageIcon(firstOperandHSV));
            lblSecondOperandHSV.setIcon(new ImageIcon(secondOperandHSV));
        }
    }

    //~ Methods ----------------------------------------------------------------

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        lblFirstOperand = new javax.swing.JLabel();
        lblSecondOperand = new javax.swing.JLabel();
        lblResultRGB = new javax.swing.JLabel();
        cmdOperation = new javax.swing.JComboBox();
        pnlResultRGBJAI = new javax.swing.JPanel();
        lblResultHSV = new javax.swing.JLabel();
        lblFirstOperandRGB = new javax.swing.JLabel();
        lblSecondOperandRGB = new javax.swing.JLabel();
        lblFirstOperandHSV = new javax.swing.JLabel();
        lblSecondOperandHSV = new javax.swing.JLabel();
        lblRGB = new javax.swing.JLabel();
        lblHSV = new javax.swing.JLabel();
        pnlResultHSVJAI = new javax.swing.JPanel();
        lblResultRGBRGB = new javax.swing.JLabel();
        lblResultRGBHSV = new javax.swing.JLabel();
        lblResultHSVRGB = new javax.swing.JLabel();
        lblResultHSVHSV = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(new java.awt.GridBagLayout());

        lblFirstOperand.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblFirstOperand.text")); // NOI18N
        lblFirstOperand.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        lblFirstOperand.setVerticalTextPosition(javax.swing.SwingConstants.TOP);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        getContentPane().add(lblFirstOperand, gridBagConstraints);

        lblSecondOperand.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblSecondOperand.text")); // NOI18N
        lblSecondOperand.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        lblSecondOperand.setVerticalTextPosition(javax.swing.SwingConstants.TOP);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        getContentPane().add(lblSecondOperand, gridBagConstraints);

        lblResultRGB.setText(org.openide.util.NbBundle.getMessage(ColorTester.class, "ColorTester.lblResultRGB.text")); // NOI18N
        lblResultRGB.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        lblResultRGB.setVerticalTextPosition(javax.swing.SwingConstants.TOP);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 0;
        getContentPane().add(lblResultRGB, gridBagConstraints);

        cmdOperation.setModel(new javax.swing.DefaultComboBoxModel(
                new String[] { "Addition", "Subtraction", "Multiplication", "Division" }));
        cmdOperation.addActionListener(new java.awt.event.ActionListener() {

                @Override
                public void actionPerformed(final java.awt.event.ActionEvent evt) {
                    cmdOperationActionPerformed(evt);
                }
            });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 4;
        getContentPane().add(cmdOperation, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        getContentPane().add(pnlResultRGBJAI, gridBagConstraints);

        lblResultHSV.setText(org.openide.util.NbBundle.getMessage(ColorTester.class, "ColorTester.lblResultHSV.text")); // NOI18N
        lblResultHSV.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        lblResultHSV.setVerticalTextPosition(javax.swing.SwingConstants.TOP);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 0;
        getContentPane().add(lblResultHSV, gridBagConstraints);

        lblFirstOperandRGB.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblFirstOperandRGB.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        getContentPane().add(lblFirstOperandRGB, gridBagConstraints);

        lblSecondOperandRGB.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblSecondOperandRGB.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        getContentPane().add(lblSecondOperandRGB, gridBagConstraints);

        lblFirstOperandHSV.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblFirstOperandHSV.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        getContentPane().add(lblFirstOperandHSV, gridBagConstraints);

        lblSecondOperandHSV.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblSecondOperandHSV.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        getContentPane().add(lblSecondOperandHSV, gridBagConstraints);

        lblRGB.setText(org.openide.util.NbBundle.getMessage(ColorTester.class, "ColorTester.lblRGB.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        getContentPane().add(lblRGB, gridBagConstraints);

        lblHSV.setText(org.openide.util.NbBundle.getMessage(ColorTester.class, "ColorTester.lblHSV.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        getContentPane().add(lblHSV, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 3;
        getContentPane().add(pnlResultHSVJAI, gridBagConstraints);

        lblResultRGBRGB.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblResultRGBRGB.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 1;
        getContentPane().add(lblResultRGBRGB, gridBagConstraints);

        lblResultRGBHSV.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblResultRGBHSV.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 1;
        getContentPane().add(lblResultRGBHSV, gridBagConstraints);

        lblResultHSVRGB.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblResultHSVRGB.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 2;
        getContentPane().add(lblResultHSVRGB, gridBagConstraints);

        lblResultHSVHSV.setText(org.openide.util.NbBundle.getMessage(
                ColorTester.class,
                "ColorTester.lblResultHSVHSV.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 2;
        getContentPane().add(lblResultHSVHSV, gridBagConstraints);

        pack();
    } // </editor-fold>//GEN-END:initComponents

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdOperationActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_cmdOperationActionPerformed
        if ((firstOperandRGB == null) || (secondOperandRGB == null)) {
            return;
        }
        if ((firstOperandHSV == null) || (secondOperandHSV == null)) {
            return;
        }

        final float alpha = .5F;

        String item = null;
        try {
            item = (String)cmdOperation.getSelectedItem();
        } catch (final Exception ex) {
            Exceptions.printStackTrace(ex);
        }

        int operation = ADD;
        if ("subtraction".equalsIgnoreCase(item)) {
            operation = SUB;
        } else if ("multiplication".equalsIgnoreCase(item)) {
            operation = MUL;
        }

        final int widthRGB = firstOperandRGB.getWidth();
        final int heightRGB = firstOperandRGB.getHeight();
        final int[] firstOperandRGBPixels = firstOperandRGB.getRGB(0, 0, widthRGB, heightRGB, null, 0, widthRGB);
        final int[] secondOperandRGBPixels = secondOperandRGB.getRGB(0, 0, widthRGB, heightRGB, null, 0, widthRGB);
        final int widthHSV = firstOperandHSV.getWidth();
        final int heightHSV = firstOperandHSV.getHeight();
        final int[] firstOperandHSVPixels = firstOperandHSV.getRGB(0, 0, widthHSV, heightHSV, null, 0, widthHSV);
        final int[] secondOperandHSVPixels = secondOperandHSV.getRGB(0, 0, widthHSV, heightHSV, null, 0, widthHSV);

        // HSV operation on RGB image
        final BufferedImage resultImageRGBHSV = new BufferedImage(widthRGB, heightRGB, BufferedImage.TYPE_INT_ARGB);
        float[] firstOperandHSB = new float[3];
        float[] secondOperandHSB = new float[3];
        float[] resultHSB = new float[3];

        for (int y = 0; y < heightRGB; y++) {
            for (int x = 0; x < widthRGB; x++) {
                final int index = (y * widthRGB) + x;
                final int firstOperandA = (firstOperandRGBPixels[index] >> 24) & 0xff;
                final int firstOperandR = (firstOperandRGBPixels[index] >> 16) & 0xff;
                final int firstOperandG = (firstOperandRGBPixels[index] >> 8) & 0xff;
                final int firstOperandB = firstOperandRGBPixels[index] & 0xff;
                final int secondOperandA = (secondOperandRGBPixels[index] >> 24) & 0xff;
                final int secondOperandR = (secondOperandRGBPixels[index] >> 16) & 0xff;
                final int secondOperandG = (secondOperandRGBPixels[index] >> 8) & 0xff;
                final int secondOperandB = secondOperandRGBPixels[index] & 0xff;

                Color.RGBtoHSB(firstOperandR, firstOperandG, firstOperandB, firstOperandHSB);
                Color.RGBtoHSB(secondOperandR, secondOperandG, secondOperandB, secondOperandHSB);

                if (operation == ADD) {
                    resultHSB[0] = (alpha * firstOperandHSB[0]) + ((1 - alpha) * secondOperandHSB[0]);
                } else if (operation == SUB) {
//                    resultHSB[0] = Math.abs(firstOperandHSB[0] - secondOperandHSB[0]);
                    resultHSB[0] = (alpha * firstOperandHSB[0]) - ((1 - alpha) * secondOperandHSB[0]);
                    resultHSB[0] += 180;
                } else if (operation == MUL) {
                    resultHSB[0] = firstOperandHSB[0] * secondOperandHSB[0];
                } else if (operation == DIV) {
                    resultHSB[0] = firstOperandHSB[0] / secondOperandHSB[0];
                }
                resultHSB[0] = (resultHSB[0] < 0) ? 0 : ((resultHSB[0] > 360) ? 360 : resultHSB[0]);
                resultHSB[1] = 1F;
                resultHSB[2] = 1F;

                resultImageRGBHSV.setRGB(x, y, Color.HSBtoRGB(resultHSB[0], resultHSB[1], resultHSB[2]));
            }
        }
        lblResultRGBHSV.setIcon(new ImageIcon(resultImageRGBHSV));

        // HSV operation on HSV image
        final BufferedImage resultImageHSVHSV = new BufferedImage(widthHSV, heightHSV, BufferedImage.TYPE_INT_ARGB);
        firstOperandHSB = new float[3];
        secondOperandHSB = new float[3];
        resultHSB = new float[3];

        for (int y = 0; y < heightHSV; y++) {
            for (int x = 0; x < widthHSV; x++) {
                final int index = (y * widthHSV) + x;

                final int firstOperandA = (firstOperandHSVPixels[index] >> 24) & 0xff;
                final int firstOperandR = (firstOperandHSVPixels[index] >> 16) & 0xff;
                final int firstOperandG = (firstOperandHSVPixels[index] >> 8) & 0xff;
                final int firstOperandB = firstOperandHSVPixels[index] & 0xff;
                final int secondOperandA = (secondOperandHSVPixels[index] >> 24) & 0xff;
                final int secondOperandR = (secondOperandHSVPixels[index] >> 16) & 0xff;
                final int secondOperandG = (secondOperandHSVPixels[index] >> 8) & 0xff;
                final int secondOperandB = secondOperandHSVPixels[index] & 0xff;

                Color.RGBtoHSB(firstOperandR, firstOperandG, firstOperandB, firstOperandHSB);
                Color.RGBtoHSB(secondOperandR, secondOperandG, secondOperandB, secondOperandHSB);

                if (operation == ADD) {
                    resultHSB[0] = (alpha * firstOperandHSB[0]) + ((1 - alpha) * secondOperandHSB[0]);
                } else if (operation == SUB) {
//                    resultHSB[0] = Math.abs(firstOperandHSB[0] - secondOperandHSB[0]);
                    resultHSB[0] = (alpha * firstOperandHSB[0]) - ((1 - alpha) * secondOperandHSB[0]);
                    resultHSB[0] += 180;
                } else if (operation == MUL) {
                    resultHSB[0] = firstOperandHSB[0] * secondOperandHSB[0];
                } else if (operation == DIV) {
                    resultHSB[0] = firstOperandHSB[0] / secondOperandHSB[0];
                }
                resultHSB[0] = (resultHSB[0] < 0) ? 0 : ((resultHSB[0] > 360) ? 360 : resultHSB[0]);
                resultHSB[1] = 1F;
                resultHSB[2] = 1F;

                resultImageHSVHSV.setRGB(x, y, Color.HSBtoRGB(resultHSB[0], resultHSB[1], resultHSB[2]));
            }
        }
        lblResultHSVHSV.setIcon(new ImageIcon(resultImageHSVHSV));

        // RGB operation on RGB image
        final BufferedImage resultImageRGBRGB = new BufferedImage(widthRGB, heightRGB, BufferedImage.TYPE_INT_ARGB);

        for (int y = 0; y < heightRGB; y++) {
            for (int x = 0; x < widthRGB; x++) {
                final int index = (y * widthRGB) + x;

                final int firstOperandA = (firstOperandRGBPixels[index] >> 24) & 0xff;
                final int firstOperandR = (firstOperandRGBPixels[index] >> 16) & 0xff;
                final int firstOperandG = (firstOperandRGBPixels[index] >> 8) & 0xff;
                final int firstOperandB = firstOperandRGBPixels[index] & 0xff;
                final int secondOperandA = (secondOperandRGBPixels[index] >> 24) & 0xff;
                final int secondOperandR = (secondOperandRGBPixels[index] >> 16) & 0xff;
                final int secondOperandG = (secondOperandRGBPixels[index] >> 8) & 0xff;
                final int secondOperandB = secondOperandRGBPixels[index] & 0xff;

                final int[] dst = new int[4];

//                final float a = alpha * firstOperandA / 255f;
                final float a = .5F;
                final float ac = 1 - a;
                if (operation == ADD) {
//                    dst[0] = (int) ((firstOperandA * alpha) + (secondOperandA * ac));
                    dst[1] = (int)((a * firstOperandR) + (ac * secondOperandR));
                    dst[2] = (int)((a * firstOperandG) + (ac * secondOperandG));
                    dst[3] = (int)((a * firstOperandB) + (ac * secondOperandB));
//                    dst[0] = (int) ((firstOperandA) + (secondOperandA));
//                    dst[1] = (int) ((firstOperandR) + (secondOperandR));
//                    dst[2] = (int) ((firstOperandG) + (secondOperandG));
//                    dst[3] = (int) ((firstOperandB) + (secondOperandB));
                } else if (operation == SUB) {
//                    dst[0] = firstOperandA - secondOperandA;
//                    dst[1] = firstOperandR - secondOperandR;
//                    dst[2] = firstOperandG - secondOperandG;
//                    dst[3] = firstOperandB - secondOperandB;

//                    dst[0] = clamp(dst[0]);
//                    dst[1] = clamp(dst[1]);
//                    dst[2] = clamp(dst[2]);
//                    dst[3] = clamp(dst[3]);

                    dst[1] = (int)((a * firstOperandR) - (ac * secondOperandR));
                    dst[2] = (int)((a * firstOperandG) - (ac * secondOperandG));
                    dst[3] = (int)((a * firstOperandB) - (ac * secondOperandB));
                    dst[1] += 127;
                    dst[2] += 127;
                    dst[3] += 127;
                } else if (operation == MUL) {
//                    dst[0] = firstOperandA * secondOperandA;
                    dst[1] = firstOperandR * secondOperandR;
                    dst[2] = firstOperandG * secondOperandG;
                    dst[3] = firstOperandB * secondOperandB;

                    dst[0] = clamp(dst[0]);
                    dst[1] = clamp(dst[1]);
                    dst[2] = clamp(dst[2]);
                    dst[3] = clamp(dst[3]);
                } else if (operation == DIV) {
//                    dst[0] = firstOperandA / secondOperandA;
                    dst[1] = firstOperandR / secondOperandR;
                    dst[2] = firstOperandG / secondOperandG;
                    dst[3] = firstOperandB / secondOperandB;
                }

                dst[0] = 255;

                resultImageRGBRGB.setRGB(x, y, (dst[0] << 24) | (dst[1] << 16) | (dst[2] << 8) | dst[3]);
            }
        }
        lblResultRGBRGB.setIcon(new ImageIcon(resultImageRGBRGB));

        // RGB operation on HSV image
        final BufferedImage resultImageHSVRGB = new BufferedImage(widthHSV, heightHSV, BufferedImage.TYPE_INT_ARGB);

        for (int y = 0; y < heightHSV; y++) {
            for (int x = 0; x < widthHSV; x++) {
                final int index = (y * widthHSV) + x;

                final int firstOperandA = (firstOperandHSVPixels[index] >> 24) & 0xff;
                final int firstOperandR = (firstOperandHSVPixels[index] >> 16) & 0xff;
                final int firstOperandG = (firstOperandHSVPixels[index] >> 8) & 0xff;
                final int firstOperandB = firstOperandHSVPixels[index] & 0xff;
                final int secondOperandA = (secondOperandHSVPixels[index] >> 24) & 0xff;
                final int secondOperandR = (secondOperandHSVPixels[index] >> 16) & 0xff;
                final int secondOperandG = (secondOperandHSVPixels[index] >> 8) & 0xff;
                final int secondOperandB = secondOperandHSVPixels[index] & 0xff;

                final int[] dst = new int[4];

//                final float a = alpha * firstOperandA / 255f;
                final float a = 0.5F;
                final float ac = 1 - a;
                if (operation == ADD) {
//                    dst[0] = (int) ((firstOperandA * alpha) + (secondOperandA * ac));
                    dst[1] = (int)((a * firstOperandR) + (ac * secondOperandR));
                    dst[2] = (int)((a * firstOperandG) + (ac * secondOperandG));
                    dst[3] = (int)((a * firstOperandB) + (ac * secondOperandB));
//                    dst[0] = (int) ((firstOperandA) + (secondOperandA));
//                    dst[1] = (int) ((firstOperandR) + (secondOperandR));
//                    dst[2] = (int) ((firstOperandG) + (secondOperandG));
//                    dst[3] = (int) ((firstOperandB) + (secondOperandB));
                } else if (operation == SUB) {
//                    dst[0] = firstOperandA - secondOperandA;
//                    dst[1] = firstOperandR - secondOperandR;
//                    dst[2] = firstOperandG - secondOperandG;
//                    dst[3] = firstOperandB - secondOperandB;
//
//                    dst[0] = clamp(dst[0]);
//                    dst[1] = clamp(dst[1]);
//                    dst[2] = clamp(dst[2]);
//                    dst[3] = clamp(dst[3]);

                    dst[1] = (int)((a * firstOperandR) - (ac * secondOperandR));
                    dst[2] = (int)((a * firstOperandG) - (ac * secondOperandG));
                    dst[3] = (int)((a * firstOperandB) - (ac * secondOperandB));
                    dst[1] += 127;
                    dst[2] += 127;
                    dst[3] += 127;
                } else if (operation == MUL) {
//                    dst[0] = firstOperandA * secondOperandA;
                    dst[1] = firstOperandR * secondOperandR;
                    dst[2] = firstOperandG * secondOperandG;
                    dst[3] = firstOperandB * secondOperandB;

                    dst[0] = clamp(dst[0]);
                    dst[1] = clamp(dst[1]);
                    dst[2] = clamp(dst[2]);
                    dst[3] = clamp(dst[3]);
                } else if (operation == DIV) {
//                    dst[0] = firstOperandA / secondOperandA;
                    dst[1] = firstOperandR / secondOperandR;
                    dst[2] = firstOperandG / secondOperandG;
                    dst[3] = firstOperandB / secondOperandB;
                }

                dst[0] = 255;

                resultImageHSVRGB.setRGB(x, y, (dst[0] << 24) | (dst[1] << 16) | (dst[2] << 8) | dst[3]);
            }
        }
        lblResultHSVRGB.setIcon(new ImageIcon(resultImageHSVRGB));

        if ("division".equalsIgnoreCase(item)) {
            operation = DIV;
        }

        // JAI on RGB image
        ParameterBlock resultParameterBlock = new ParameterBlock();
        resultParameterBlock.addSource(secondOperandRGBJAI);
        resultParameterBlock.addSource(firstOperandRGBJAI);

        pnlResultRGBJAI.removeAll();
        PlanarImage planarImage = null;
        if (operation == ADD) {
            // Simple
// planarImage = JAI.create("add", resultParameterBlock);

            // More complex
            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(firstOperandRGBJAI);
            resultParameterBlock.add(new double[] { .5D, .5D, .5D, 1D });
            resultParameterBlock.add(new double[] { 0D, 0D, 0D, 0D });
            final PlanarImage firstOperandScaled = JAI.create("rescale", resultParameterBlock);

            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(secondOperandRGBJAI);
            resultParameterBlock.add(new double[] { .5D, .5D, .5D, 1D });
            resultParameterBlock.add(new double[] { 0D, 0D, 0D, 0D });
            final PlanarImage secondOperandScaled = JAI.create("rescale", resultParameterBlock);

            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(secondOperandScaled);
            resultParameterBlock.addSource(firstOperandScaled);
            planarImage = JAI.create("add", resultParameterBlock);
        } else if (operation == SUB) {
            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(secondOperandRGBJAI);
            resultParameterBlock.addSource(firstOperandRGBJAI);
            planarImage = JAI.create("subtract", resultParameterBlock);

//            resultParameterBlock = new ParameterBlock();
//            resultParameterBlock.add(new double[]{1D, 1D, 1D, 0D});
//            resultParameterBlock.add(new double[]{0D, 0D, 0D, 255D});
//            resultParameterBlock.addSource(planarImage);
//            planarImage = JAI.create("rescale", resultParameterBlock);

            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(planarImage);
            resultParameterBlock.add(
                new double[][] {
                    { 2D, 0D, 0D, 0D, 0D },
                    { 0D, 2D, 0D, 0D, 0D },
                    { 0D, 0D, 0D, 0D, 0D },
                    { 1D, 1D, 0D, 0D, 0D },
                });
            planarImage = JAI.create("bandcombine", resultParameterBlock);
        } else if (operation == MUL) {
            // Invert the red band of the addition and use it as green band
            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(secondOperandRGBJAI);
            resultParameterBlock.addSource(firstOperandRGBJAI);
            final PlanarImage normalAddition = JAI.create("add", resultParameterBlock);

            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(normalAddition);
            // Red as source for color space transformation
            resultParameterBlock.add(
                new double[][] {
                    { 1D, 0D, 0D, 0D, 0D },
                    { -1D, 0D, 0D, 0D, 255D },
                    { 0D, 0D, 0D, 0D, 0D },
                    { 0D, 0D, 0D, 0D, 255D },
                });
            // Green as source for color space transformation
// resultParameterBlock.add(new double[][]{
// { 0D, -1D, 0D, 0D, 255D },
// { 0D, 1D, 0D, 0D, 0D },
// { 0D, 0D, 0D, 0D, 0D },
// { 0D, 0D, 0D, 0D, 255D },
// });
            planarImage = JAI.create("bandcombine", resultParameterBlock);
        } else if (operation == DIV) {
            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.addSource(secondOperandRGBJAI);
            resultParameterBlock.addSource(firstOperandRGBJAI);
            planarImage = JAI.create("subtract", resultParameterBlock);

            resultParameterBlock = new ParameterBlock();
            resultParameterBlock.add(new double[] { 1D, 1D, 1D, 0D });
            resultParameterBlock.add(new double[] { 0D, 0D, 0D, 255D });
            resultParameterBlock.addSource(planarImage);
            planarImage = JAI.create("rescale", resultParameterBlock);
        }

        if (planarImage != null) {
            pnlResultRGBJAI.add(new javax.media.jai.widget.ScrollingImagePanel(planarImage, 250, 250));

//            try {
//                final File outputFile = new File("D:\\Caches\\xy\\" + operation + "_" + System.currentTimeMillis()
//                                + ".png");
//                final FileOutputStream stream = new FileOutputStream(outputFile);
//                JAI.create("encode", planarImage, stream, "PNG", null);
//                stream.flush();
//                stream.close();
//
//                // Store the image in the BMP format.
//// JAI.create(
//// "filestore",
//// resultImage,
//// "D:\\Caches\\xy\\1_"
//// // + operation.name()
//// // + "_"
//// + System.currentTimeMillis()
//// + ".tif",
//// "TIFF",
//// null);
//
//                final File outputFileBuffered = new File("D:\\Caches\\xy\\BI_" + operation + "_"
//                                + System.currentTimeMillis()
//                                + ".png");
//                ImageIO.write(planarImage.getAsBufferedImage(), "png", outputFileBuffered);
//            } catch (final Exception ex) {
//                // NoOp
//            }
        }

        // JAI on HSV image
        resultParameterBlock = new ParameterBlock();
        resultParameterBlock.addSource(secondOperandHSVJAI);
        resultParameterBlock.addSource(firstOperandHSVJAI);

        pnlResultHSVJAI.removeAll();
        planarImage = null;
        if (operation == ADD) {
            planarImage = JAI.create("add", resultParameterBlock);
        } else if (operation == SUB) {
            planarImage = JAI.create("subtract", resultParameterBlock);
        } else if (operation == MUL) {
            planarImage = JAI.create("multiply", resultParameterBlock);
        } else if (operation == DIV) {
            planarImage = JAI.create("divide", resultParameterBlock);
        }

        if (planarImage != null) {
            pnlResultHSVJAI.add(new javax.media.jai.widget.ScrollingImagePanel(planarImage, 250, 250));
        }
    } //GEN-LAST:event_cmdOperationActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param   a  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    static int clamp(final int a) {
        return (a < 0) ? 0 : ((a > 255) ? 255 : a);
    }

    /**
     * DOCUMENT ME!
     *
     * @param  args  the command line arguments
     */
    public static void main(final String[] args) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (final javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ColorTester.class.getName())
                    .log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ColorTester.class.getName())
                    .log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ColorTester.class.getName())
                    .log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ColorTester.class.getName())
                    .log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

                @Override
                public void run() {
                    new ColorTester().setVisible(true);
                }
            });
    }
}
